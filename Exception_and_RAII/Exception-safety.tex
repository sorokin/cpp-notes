\section{Exception safety}
\subsection{Мотивирующий пример}
Пусть у нас есть функция \mintinline{c++}{vector::resize()};

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template<typename T>
void vector<T>::resize(size_t size) {
    if (size > curr_size) {
        cnt_add = size - curr_size; // количество элементов для добавления.
        for (size_t i = 0; i < cnt_add; ++i) {
            push_back(T());
        }
    }
}
\end{minted}


Это код не использует исключения, то есть не вызывает их и не обрабатывает. Но если будет ошибка выделения памяти при расширении вектора, то исключение возникнет в функции push\_back(), потом пробросятся через resize() наружу.

То есть проблема в том, что мы не используя механизм исключений все равно можем получить от него проблемы. Как например, не пойманное исключение.

\subsection{Определение}

Поэтому существуют Гарантии безопасности исключений (Exception safety). Это некий контракт исключений, который представляет из себя ряд уровней безопасности, которые присваиваются всем методам класса. Они декларируют выполнение некоторого контракта относительно состояния объекта после выполнения операций над ним.

Уровни гарантий:
\begin{enumerate}
\item \textbf{<<No guarantees>>} - нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что продолжать работу программы нельзя.
\item \textbf{<<Basic guarantees>>} - Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
\item \textbf{<<Strong guarantees>>} - Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
\item \textbf{<<Nothrow guarantees>>} - Кроме базовой гарантии, гарантируется, что исключения не возникают.
\end{enumerate}

\subsection{Основные моменты}

Теперь давайте рассмотрим важные моменты:
\begin{itemize}
\item Методы пользовательского интерфейса должны удовлетворять базовым или строгим гарантиям. Это избавляет пользователей от утечек памяти и инвалидных данных.

\item Также важно, чтобы деструктор не пробросал исключений, иначе утечки неизбежны. Например, может возникнуть исключение и при очистки стека, возникает еще одно.

\item Важность гарантии nothrow:
Она есть у очень небольшого количества функции: swap, vector::pop\_back, операции с итераторами, Это гарантия очень важна, так как с ее помощью достигается строгая гарантия, когда мы производим необходимы операции на временном объекте, а потом просто делаем с ним swap.
\end{itemize}

\subsection{Best practice}

Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
vector<T>& vector<T>::operator=(vector const& other) {
    return this->swap(vector(other)); // swap trick!
}
\end{minted}

Мы копируем other во временный объект vector(other), а потом делаем swap с ним. Если произойдет исключение при копировании other во временный объект, то оно пробросится к нам. swap() не выполнится и исключение проброситься дальше. Наш объект не поменяется.

\textcolor{red}{NB}) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.

Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

\textcolor{red}{Offtops:}

Можно попросить оператор \mintinline{c++}{new} не кидать исключение с помощью константы \mintinline{c++}{std::nothrow}
