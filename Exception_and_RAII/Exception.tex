\section{Exceptions}
\subsection{Введение}
Часто нехватка динамической памяти, неправильный ввод пользователя, ошибка с файловой системой, приводят к тому, что продолжение исполнения логики программы не возможно. Например, если наша функция foo вызывает malloc и malloc вернул ошибку, то функция foo должна завершится и тоже вернуть ошибку. Возможно, что вызывающая сторона функции foo, тоже проверит возвращаемое значение функции foo и завершится с ошибкой.

В C это поведение достигалось, явной проверкой возвращаемого значения функции с помощю if и return'а в случае ошибки. C++ имеет встроенный в язык механизм поддержки такого поведения. Он называется механизмом исключений.

Рассмотрим следующую функцию деления:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void div(int a, int b) {
    return a / b;
}
\end{minted}

Если в эту функцию передать в качестве $b$ $0$, то произойдет undefined behavior. Предположим, что мы хотим, чтобы функция сообщала об ошибке, когда $b = 0$. Для этого сначала необходимо объявить класс исключения, объекты которого будут хранить в себе информацию об исключении.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class Division_by_zero() {
    int dividend
    string message;
    Division_by_zero(int &dividend, string const &message) :
        dividend(dividend), message(message) { }
};
\end{minted}

Теперь можно переписать функцию $div$ следующим образом:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void div(int a, int b) {
    if (b == 0) // возникает исключительное состояние
        throw Division_by_zero(a, "in function div(int, int)"); // генерируем исключение.
    return a / b;
}
\end{minted}

Оператор throw завершает исполнение текущей функции и возвращает ошибку в вызывающую функцию. Вызывающая сторона может обрабатывать исключение следующим образом:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int main() {
    int n;
    cin >> n;
    try { // здесь указываем опрераторы, в которых мы хотим ловить исключения.
        for (int i = 0, a, b; i < n; ++i) {
            cin >> a >> b;
            cout << div(a, b);
        }
    } catch(Division_by_zero const& obj) { //здесь указываем тип исключения, которое мы хотим обработать
    // здесь обрабатываем исключение
        cout << obj.dividend << "div by 0 " << obj.message();
    }
}
\end{minted}

В данном примере, при завершении div с исключением, цикл for прерывается и исполняется catch-блок, который выводит сообщение об ошибке. После чего функция main завершается.

Если исключения не возникает, то цикл for отработает до конца, catch-блок вызван не будет.

\subsection{Описание конструкций}
Рассмотрим используемые конструкции подробнее:

\mintinline{c++}{try{}} -- защищенный блок. Здесь пишется код, исключения в котором необходимо ловить и обрабатывать.

\mintinline{c++}{catch(){}} -- блок перехвата исключений или блок обработки или обработчик. Здесь будут ловиться исключения, тип которых совпадает по определенным правилам с типом указанным в (), и обрабатываться инструкциями в \{\}

\mintinline{c++}{throw} -- оператор генерирует исключение. (Иногда говорят, "бросает"\ или "выбрасывает"\ исключение)

Теперь давай рассмотрим детали работы этого механизма.

Блок \mintinline{c++}{try-catch} используется для обработки исключений. И имеет общий вид:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
try { /*операторы защищенного блока*/ }
// catch-блоки
catch(exception1 const& e) {/*код обработки*/}
catch(exception2 const& e) {/*код обработки*/}
...
catch(exceptionN const& e) {/*код обработки*/}

\end{minted}
Если изнутри блока try вылетит исключение то, компилятор попытается подобрать подходящий catch-блок. В catch блоке указывается какие действия необходимо сделать, при возникновении исключения указанного типа.

Catch-блок может иметь две формы:
\begin{itemize}
    \item
    \mintinline{c++}{catch(/*declaration*/) { /*обработчик исключения*/ }} Ловит исключение указанного или производных от него типов. Переменной исключения можно дать имя. Это позволяет обращаться к объекту исключения.
    \item
    \mintinline{c++}{catch(...) { /*обработчик исключения*/ }}
    Ловит исключения всех типов. В этом случае невозможно обращаться к объекту исключения.
\end{itemize}

Что происходит, когда мы генерируем исключение:
\begin{enumerate}
    \item
    Создается копия объекта переданного в оператор throw. Этот объект будет существовать до тех пор, пока исключение не будет обработано. Если тип объекта имеет конструктор копирования, то он будет вызван.
    \item
    Прерывается исполнение программы.
    \item
    Выполняется раскрутка стека, пока исключение не будет обработано.
\end{enumerate}

При раскрутке стека, вызываются деструкторы локальных переменных в обратном порядке их объявления. После разрушения всех локальных объектов текущей функции процесс продолжается в вызывающей функции. Раскрутка стека продолжается пока не будет найден try-catch-блок. При нахождении try-catch-блока, проверяется, может ли исключение быть обработано одним их catch-блоков.

\subsection{Как ловится исключение?}

Catch-блоки проверяются в том порядке, в котором написаны. Обработчик считается подходящим если:
\begin{enumerate}
    \item
    Тип, указанный в catch-блоке, совпадает с типом исключения или является ссылкой на этот тип.
    \item
    Класс, заданный в catch-блоке, является предком класса, заданного в throw, и наследование открытое (public).
    \item
    Указатель, заданный в операторе throw, может быть преобразован по стандартным правилам к указателю, заданному в catch-блоке.
    \item
    В catch-блоке указанно многоточие.
\end{enumerate}

Если найдет нужный catch-блок, то выполняется его код, остальные catch-блоки игнорируются, а выполнение продолжается после try...catch-блока и исключение считается обработанным. Если ни один catch-блок не подошел, процесс раскрутки стека продолжается.

\textcolor{red}{NB}) Так как поиск ведется последовательно, то нужно учитывать порядок catch-блоков (Например, catch(...) должен быть последним).

\textcolor{red}{NB}) Также при наследовании классов исключений следует различать catch(type\& obj) и catch(type obj). В первом случае obj ссылается на этот объект и копии не создается. Во втором случае при входе в catch блок делается копия объекта-исключения, вследствии чего мы теряем возможность вызывать виртуальные функции.

Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct Exception_base {
    virtual char const* msg() const {
        return "base";
    }
};

struct Exception_derived : Exception_base {
    virtual char const* msg() const {
        return "derived";
    }
};

int f() {
    try {
        throw Exception_derived();
    }
    catch (base e) {
        std::cout << e.msg() << std::endl;
    }
}

int g() {
    try {
        throw Exception_derived();
    }
    catch (base const& e) {
        std::cout << e.msg() << std::endl;
    }
}
\end{minted}

В данном примере g() выводит <<derived>>, а функция f() выводит <<base>>, поскольку объект исключения был скопирован с базы объекта, который мы передали в оператор throw и новая копия имеет тип base.

В некоторых случаях внутри catch-блока может быть необходимо не завершать раскрутку стека. Для этого существует специальная форма оператора throw без аргумента. Она означает проброс текущего исключения с сохранением его типа.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}

struct Exception_base {
    virtual char const* msg() const {
        return "base";
    }
};

struct Exception_derived : Exception_base {
    virtual char const* msg() const {
        return "derived";
    }
};

void thrid() {
    throw Exception_derived();
}

void second() {
    try {
        thrid()
    }
    catch (Exception_base const &obj) {
        std::cout << obj.msg();
        throw;
    }
}

void first () {
    try {
        second();
    }
    catch (Exception_derived const &obj) {
        std::cout << obj.msg();
    }
}

int main() {
    first();
    return 0;
}

\end{minted}

\textbf{Вывод программы:} \\
> base \\
> derived \\

Значит тип объекта-параметра в текущем catch-блоке может отличаться от типа исключения, и это не влияет на дальнейшую обработку исключения в других catch-блоках.

 Например, это позволяет найти выход из такой ситуации: мы захотели вставить куда-то в глубь уже написанного кода try-catch-блок для логирования всех исключений. Тогда будем ловить по типу Exception\_all, который сделаем предком всех наший исключений. Ловим и пробрасывать дальше, чтобы не нарушать обработку производный от него исключений.

 \textcolor{red}{NB})Если необходимо изменить тип исключения, то мы можем в конце catch-блока сразу кинуть новое исключение нового типа. 

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int main()
{
    try {
        try {
            throw derived();
        }
        catch (base const& e) {
            throw e;
        }
    }
    catch (base const& e) { ... }
}
\end{minted}

\subsection{Function-try-block}

Часто мы хотим, чтобы все тело функции находилось в try-блоке. Тогда это try-блок называется функциональным. И для него есть отдельный синтаксис.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int main() try {
    //main's body
}
catch (...) { }
\end{minted}

Здесь функциональные try-блоки являются синтаксическим сахаром, но есть ситуации когда без них не обойтись: обработка исключений в конструкторе.

Вот есть класс, котором мы хотим ловить и обрабатывать исключения.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class St {
public:
    St(): member() {
        try {
            // Constructor's code
        }
        catch (...) { }
    }
private:
    Member_type member;
}
\end{minted}

Но заметим, что вызов конструкторов членов не находится внутри try-блока и исключения возникшие в их конструкторах не поймаются.
Поэтому мы используем здесь функциональный try-блок:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class St {
public:
    St() try: member() {
        // Constructor's code
    }
    catch (...) {

    } // implicit throw
}
private:
    Member_type member;
}
\end{minted}

Но у функциональный try-блок в конструкторах, есть особенность: они всегда бросают исключение повторно.

\subsection{Уничтожение объекта при исключении в конструкторе}

Также важно помнить, что если в конструкторе происходит исключение, то для него не вызовется деструктор, так как объект еще не считается созданным. Захваченные ресурсы придется очищать руками

Важно понимать, что происходить в конструкторе когда возникает исключение. Если исключение возникает при созднии члена класса, то от всех уже созданных членов вызываются деструкторы. Но от самого объекта деструктор не вызвается, так как объект не считается созданным пока хотя бы один конструктор не отработал полностью. Поэтому при необходимости нужно либо руками освобождать захваченные ресурсы, либо декларировать небросающему конструктору.

\subsection{Best practice}
Часто исключения применяются для корректной работы с ресурсами. То есть если возникает исключение и мы владеем какими-то ресурсам, то в случае генерации исключения следует их освободить.

Например, мы пишем конструктор копирования для вектора, и нам необходимо скопировать данные в другой участок памяти. При этом если во время копирование какого-то объекта возникнет исключение, то хорошо если уже созданные объекты будут разрушены. Причем желательно в обратном порядке их создания.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void copy_construct(T* dist, T const * sourse, size_t size) {
    size_t i = 0;
    try {
        for (; i != size; ++i) {
            new (dist + i) T(sourse[i]);
        }
    }
    catch (...) { // если ошибка при копировании
        for (size_t j = i; j != 0; --j) {
            dist[j - 1].~T(); // вызовем деструкторы созданных объектов
        }
        throw;
    }
}
\end{minted}

Полезно знать про стандартные исключения, такие как  \mintinline{c++}{std::bad_alloc}, \mintinline{c++}{std::bad_cast}, \mintinline{c++}{std::bad_typeid} и т. д. Они также связанны наследованием и имеют общего предка \mintinline{c++}{std::exception}.

Подробнее можно почитать здесь: \\
\url{https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm} \\
\url{http://en.cppreference.com/w/cpp/error/exception} \\

Хорошим тоном является наследование от \mintinline{c++}{std::exception}.

Когда мы организовываем исключения в иерархии классов, то получаем мощный механизм описания исключение и способов их обработки. Создав такую структуры мы можем обрабатывать как более общие ошибки, так и более специализированные.
Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
    class StackException {};
    class popOnEmpty(): public StackException {};
    class pushOnFull(): public StackException {};
\end{minted}
	Причем сгенерировав исключение типа popOnEmpty(), мы можем в разных обработчиках независимо выбирать: обработать как popOnEmpty или как StackException, так как тип исключения не теряется при повторной генерации этого исключения.

\subsection{Bad practice}
\begin{itemize}
\item
Плохо писать код бросающий исключения в catch-блоке.
\item
Хотя если исключений не происходит, то по скорости выполнения программа не сильно упадет, но иногда нужно учитывать большой overhead в случае возникновения и обработки исключения.
\end{itemize}

\subsection{std::terminate()}

Это функция, которая вызывается если у механизма исключений не получается корректно отработать, чтобы завершить программу.
Случаи когда она вызывается:
\begin{itemize}
\item Исключение брошено и не поймано ни одним catch-блоком, то есть пробрасывается вне main().
\item Исключение бросается во время обработки другого исключения. Это может произойти только в catch-блоке или деструкторе. А также в функциях, которые вызываются ими.
\item Если функция переданная в \mintinline{c++}{std::atexit} и \mintinline{c++}{std::at_quick_exit} бросит исключение.
\item Если функция нарушит гарантии noexcept specification. Например, если функция помеченная как noexcept бросит исключение.
\item При подобных и не только ошибках в потоках.
\end{itemize}

По умолчанию \mintinline{c++}{std::terminate()} вызвает \mintinline{c++}{std::abort()}, но можно это изменить, написав свою функцию \mintinline{c++}{my_terminate()} и зарегистрировать ее как терминальную.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void my_terminate() {
    cout << "It's not a bug, it's a feature!";
}
/**/
set_terminate(my_teminate);
\end{minted}
