\section{Умные указатели}

Рассмотрим следующий код: 

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container();
    fill(*c);
    return c;
}
\end{minted}

В приведенном коде, при возникновении исключения в функции fill, это исключение пролетит наружу функции create\_container. Однако выделенный с помощью new контейнер c не будет освобожден. Возможным способом исправления этой ошибки является использование try…catch блока:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
container* create_container()
{
    container* c = new container(); 
    try
    {
        fill(*c);
    }
    catch(...)
    {
        delete c;
        throw;
    }
    return c;
}
\end{minted}

Такой способ применим если лишь к простейшим функциям. При начилии нескольких объектов, которые требуется удалить или в присутствии сложного control-flow такое использование try...catch становится непрактичным.

Для решения этой проблемы в C++11 появились классы умных указателей (\mintinline{c++}{std::unique_ptr}, \mintinline{c++}{std::shared_ptr} и \mintinline{c++}{std::weak_ptr}). Эти классы являются RAII-обертками над обычными указателями, которые в своём деструкторе делают \mintinline{c++}{delete} тому объекту, на который они ссылаются. При использовании \mintinline{c++}{std::unique_ptr} приведенный выше (корректный) код может быть записан следующим образом:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
std::unique_ptr<container> create_container()
{
    std::unique_ptr<container> c(new container());
    fill(*c);
    return c;
}
\end{minted}

\subsection{\mintinline{c++}{std::unique_ptr}}
Самым простым умным указателем является \mintinline{c++}{std::unique_ptr}. 
Внутри себя \mintinline{c++}{std::unique_ptr} хранит один указатель \mintinline{c++}{T* ptr} и делает ему \mintinline{c++}{delete} в дескрукторе.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template<class T>
class unique_ptr
{
private:
    T* ptr;
public:
    ~unique_ptr()
    {
        delete ptr;
    }
    ...
}
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет операторы \mintinline{c++}{*} и \mintinline{c++}{->}, поэтому им можно пользоваться как обыным указателем:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T& operator*() const { return *ptr; }
T* operator->() const noexcept { return ptr; }
\end{minted}

\mintinline{c++}{std::unique_ptr} имеет следующие функции:

\mintinline{c++}{get()} --- возвращает ptr, хранящийся внутри. \mintinline{c++}{get()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект, а имеется \mintinline{c++}{unique_ptr} на него.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* get() const { return ptr; }
\end{minted}

\mintinline{c++}{release()} --- зануляет ptr, хранящийся внутри, а старое значение возвращает наружу. \mintinline{c++}{release()} может использоваться если необходимо передать в некоторую функцию сырой указатель на объект и известно, что эта функция самостоятельно удалит переданный объект.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* release()
{
    T* tmp = ptr;
    ptr = nullptr;
    return tmp;
}
\end{minted}

\mintinline{c++}{reset(p)} --- заменяет ptr, хранящийся внутри, на p, и делает \mintinline{c++}{delete} старому ptr.
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
void reset(T* p)
{
    delete ptr;
    ptr = p;
}
\end{minted}

Оператор присваивания и конструктор копирования у \mintinline{c++}{unique_ptr} явно запрещены:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr(unique_ptr& other) = delete;
unique_ptr& operator=(unique_ptr& other) = delete;
\end{minted}
При попытке скопировать или присвоить \mintinline{c++}{unique_ptr} выдаётся ошибка на этапе компиляции.

\mintinline{c++}{unique_ptr} имеет move-оператор присваивания и move-конструктор, которые зануляют указатель, стоящий справо:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
unique_ptr& operator=(unique_ptr&& other) noexcept
{
    reset(other.release()); 
    return *this;
}

unique_ptr(unique_ptr&& other) noexcept
    : ptr(other.release())
{}
\end{minted}

\subsection{Владение}
Ответственность за удаление объекта называется владением. Например, \mintinline{c++}{std::unique_ptr} ответственен за удаление объекта на который он ссылается, соответственно говорят, что \mintinline{c++}{std::unique_ptr} владеет объектом, на который он ссылается. Про функцию \mintinline{c++}{reset(p)} говорят, что она передает владение объектом \mintinline{c++}{std::unique_ptr}'у, а функция \mintinline{c++}{release()}, наоборот, забирает владение объектом у \mintinline{c++}{std::unique_ptr}'а.

Термин владение применяется не только к умным указателям, например можно сказать, что std::vector владеет памятью выделенной под свои элементы (обязан её освободить), а также владеет своими элементами (обязан вызывать им деструктор).

В некоторых случаях объект может иметь несколько владельцев. Это называется разделяемым владением и работает следующим образом: пока существует хотя бы один владелец объект продолжает жить, когда пропадает последний владелец --- объект удаляется. Для умных указателей существует два способа реализации разделяемого владения: подсчет ссылок и провязка всех владельцев в двусвязный список. Оба подхода имеют свои преимущества и недостатки. Подсчет ссылок применяется во включенном в стандартную библиотеку указателе \mintinline{c++}{std::shared_ptr}. Указатель использующий провязку владельцев в двусвязный список в стандартной библиотеке отсутствует, но часто называется \mintinline{c++}{linked_ptr}.

\subsection{\mintinline{c++}{std::shared_ptr}}
\mintinline{c++}{std::shared_ptr} --- это умный указатель, с разделяемым владением. \mintinline{c++}{std::shared_ptr} умеет создаваться от обычного указателя и копироваться.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template<class T>
class shared_ptr
{
    // создаёт shared_ptr не ссылающийся ни на один объект
    shared_ptr();
    // создаёт shared_ptr ссылающийся на *ptr либо, если ptr == nullptr, не ссылающийся ни на один объект
    explicit shared_ptr(T* ptr);
    // создает shared_ptr ссылающийся на тот же объект, что и other
    shared_ptr(shared_ptr const& other);
    // изменяет shared_ptr так, чтобы он ссылался на тот же объект, что и rhs
    shared_ptr& operator=(shared_ptr const& rhs);
};
\end{minted}

Несколько \mintinline{c++}{shared_ptr}'ов могут ссылаться на один объект. Объект, однажды обернутый в \mintinline{c++}{shared_ptr}, будет удален в тот момент, когда не останется \mintinline{c++}{shared_ptr}'ов ссылающихся на него.

Как и \mintinline{c++}{unique_ptr} \mintinline{c++}{shared_ptr} поддерживает операции \mintinline{c++}{operator*}, \mintinline{c++}{operator->}, \mintinline{c++}{reset}, \mintinline{c++}{get} с той же семантикой, что и у \mintinline{c++}{unique_ptr}. Операция \mintinline{c++}{release} отсутствует для \mintinline{c++}{shared_ptr}'а поскольку в общем случае она не возможна, из-за того, что могут существовать другие \mintinline{c++}{shared_ptr}'ы ссылающиеся на этот же объект.

\subsubsection{Наивная реализация}

При наивной реализации \mintinline{c++}{shared_ptr} мог бы хранить указатель на ссылаемый объект и счетчик ссылок. Поскольку значение счетчика ссылок является общим между всеми \mintinline{c++}{shared_ptr} ссылающимися на данный объект, \mintinline{c++}{shared_ptr} вынужден хранить указатель на счетчик ссылок и аллоцировать память под счетчик ссылок динамически.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct shared_ptr
{
    // ...

private:
    // Класс имеет следующий инвариант:
    // Если shared_ptr не ссылается ни на один объект, и ptr и ref_counter равны nullptr.
    // Если shared_ptr ссылается на некоторый объект, и ptr и ref_counter не равны nullptr.
    // *ref_counter равен числу shared_ptr'ов ссылающихся на объект *ptr.
    T* ptr;
    size_t* ref_counter;
};

template <typename T>
shared_ptr<T>::shared_ptr()
    : ptr(nullptr)
    , ref_counter(nullptr)
{}

template <typename T>
shared_ptr<T>::shared_ptr(T* ptr)
    : ptr(ptr)
{
    if (!ptr)
        return;

    try
    {
        ref_counter = new size_t(1);
    }
    catch (...)
    {
        delete ptr;
        throw;
    }
}

template <typename T>
shared_ptr<T>::shared_ptr(shared_ptr const& other)
    : ptr(other.ptr)
    , ref_counter(other.ref_counter)
{
    if (!ptr)
        return;

    ++*ref_counter;
}    

template <typename T>
shared_ptr<T>::~shared_ptr()
{
    if (!ptr)
        return;

    if (--*ref_counter == 0)
    {
        delete ref_counter;
        delete ptr;
    }
}
\end{minted}

Нетривиальным моментом в реализации является конструктор \mintinline{c++}{shared_ptr(T* ptr)} и блок \mintinline{c++}{try...catch} внутри него. На первый взгляд может показаться, что этот блок не требуется и даже мешает, поскольку из-за него конструктор перестает удовлетворять строгой гарантии безопасности исключений. Однако существует веский аргумент в пользу такой релизации. Рассмотрим следующее использование \mintinline{c++}{shared_ptr}:

\begin{listing}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
shared_ptr<T> p(new T());
\end{minted}
\caption{Типичное создание \mintinline{c++}{shared_ptr}}
\label{listing:shared_ptr_attach_to_object}
\end{listing}

Если конструктор \mintinline{c++}{shared_ptr} при ошибке аллокации счетчика ссылок не будет удалять переданный указатель, то этот указатель нигде не будет удалён и любой код аналогичный листингу \ref{listing:shared_ptr_attach_to_object} был бы ошибочным. Поэтому конструктор \mintinline{c++}{shared_ptr} от указателя удаляет объект, если происходит ошибка аллокации счетчика ссылок. Можно сказать что конструктор \mintinline{c++}{shared_ptr} забирает владение указателем даже если он бросает исключение.

\subsubsection{Проблема разделения счетчика ссылок}
\label{reference_counter_split_problem}

Расмотрим следующий код:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
T* p = new T();
std::shared_ptr<T> p1(p);
std::shared_ptr<T> p2(p);
\end{minted}
Данный код содержит ошибку. Каждый из вызовов \mintinline{c++}{shared_ptr(T*)} создаст свой собственный счетчик ссылок. В результате получится один объект и два счетчика ссылок к нему. Объект удалится, когда хотя бы один из счетчиков ссылок достигнет нуля. Когда второй из счетчиков достигнет нуля произойдет ошибка повторного удаления. Описанная ситуация называется разделением ({\it split}) счетчика ссылок. Разделение счетчика ссылок является ошибкой и не должно возникать в корректных программах.

\subsubsection{Настраиваемый deleter}

Аналогично \mintinline{c++}{unique_ptr} \mintinline{c++}{shared_ptr} позволяет настроить как именно удалять объект, когда не осталось \mintinline{c++}{shared_ptr}'ов ссылающихся на него. В отличие от \mintinline{c++}{unique_ptr} тип \mintinline{c++}{shared_ptr} не зависит от типа deleter'а.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct shared_ptr
{
    template <typename D>
    shared_ptr(T*, D const& deleter);
};
\end{minted}

Deleter, как и счетчик ссылок, является общим для всех \mintinline{c++}{shared_ptr} ссылающихся на некоторый объект, поэтому хранится в том же блоке памяти, что и счетчик ссылок:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct shared_ptr
{
private:
    struct shared_count_base
    {
        size_t nrefs;
    };
    
    template <typename D>
    struct shared_count : shared_count_base
    {
        D deleter;
    };
    
    T* ptr;
    shared_count* ref_counter;
};
\end{minted}

\subsubsection{Aliasing конструктор}
\label{aliasing_constructor}
Иногда необходимо продлевать жизнь объекту, пока кто-то ссылается на его поля. Для этого существует специальный конструтор, называемый {\it aliasing конструктор}:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct shared_ptr
{
    // Создаёт shared_ptr ссылающийся на ptr и использующий shared_count от sp.
    template <typename U>
    shared_ptr(shared_ptr<U> const& sp, T* ptr); 
};
\end{minted}

Рассмотрим использование aliasing конструктора на примере. Пусть у нас есть машина. Машина имеет колёса. Мы хотим, чтобы пока существует указатель на колесо, машина тоже не удалялась вместе с колёсами. Это можно записать следующим образом:

\begin{listing}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct car
{
    wheel wheels[4];
};

shared_ptr<car> c;
shared_ptr<wheel> w(c, &c->wheels[2]); // w получает тот же shared_count, что и c
\end{minted}
\caption{Пример использования aliasing конструктора}
\label{listing:shared_ptr_aliasing_ctor_example}
\end{listing}

Сравним такое использование со случаем когда \mintinline{c++}{car}, содержит \mintinline{c++}{shared_ptr}'ы на \mintinline{c++}{wheel}'ы:

\begin{listing}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct car
{
    shared_ptr<wheel> wheels[4];
};

shared_ptr<car> c;
shared_ptr<wheel> w(c->wheels[2]);
\end{minted}
\caption{Пример с автомобилем и колёсами без использования aliasing конструктора}
\label{listing:shared_ptr_car_wheels_example}
\end{listing}

Примеры \ref{listing:shared_ptr_aliasing_ctor_example} и \ref{listing:shared_ptr_car_wheels_example} имеют два отличия:
\begin{enumerate}
\item В примере \ref{listing:shared_ptr_aliasing_ctor_example} имеется один объект в памяти и один счетчик ссылок. В примере \ref{listing:shared_ptr_car_wheels_example} имеется пять объектов в памяти, каждый из которых имеет свой счетчик ссылок.
\item В примере \ref{listing:shared_ptr_aliasing_ctor_example} колёса не могут существовать без автомобиля, когда умирает автомобиль удаляются все колеса. Удерживание ссылки на колесо продлевает жизнь автомобилю. В примере \ref{listing:shared_ptr_car_wheels_example} автомобиль может умереть, а колеса будут продолжать жить сами по себе.
\end{enumerate}

Для того, чтобы поддержать aliasing конструкторы в \mintinline{c++}{shared_count}'е требуется похранить ссылку на исходный объект:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct shared_ptr
{
private:
    struct shared_count_base
    {
        size_t nrefs;
    };
    
    template <typename D>
    struct shared_count : shared_count_base
    {
        T* ptr;
        D deleter;
    };
    
    T* ptr;
    shared_count* ref_counter;
};
\end{minted}

Ещё одним применением aliasing конструкторов является следующее. При хранении дерева объектов они позволяют, гарантировать, что пока существует хоть один указатель на элемент дерева, то всё дерево продолжает существовать.

\subsubsection{\mintinline{c++}{std::weak_ptr}}

Рассмотрим следующую задачу. Пусть у нас есть функция \mintinline{c++}{image load_image(string name)} загружающая картинку по имени. И пусть так оказалось, что часто пользователи этой функции загружают одну и ту же картинку несколько раз и держать в памяти несколько копий одной картинки. Требуется сделать компонент, который если изображение уже загружено, не будет загружать его второй раз, а будет переиспользовать существующее. Освобождаться изображение должно только тогда, когда последний пользователь закончил с ним работать.

Чтобы изображение удалялось только тогда, когда последний пользователь закончил с ним работать изменим пользователей, чтобы они хранили не сам \mintinline{c++}{image}, а \mintinline{c++}{shared_ptr<image>}. Для того, чтобы \mintinline{c++}{load_image} возвращала \mintinline{c++}{shared_ptr} на уже существующий \mintinline{c++}{image} если такой существует можно было бы попробовать использовать мапу:

\begin{listing}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct image_cache
{
    image_cache(image_cache const&) = delete;
    image_cache& operator=(image_cache const&) = delete;

    std::shared_ptr<image> load_image(std::string const& name)
    {
        auto i = cache.find(name);
        if (i != cache.end())
            return i->second;
            
        std::shared_ptr<image> p = real_load_image(name);
        cache.insert(i, {name, p});
        return p;
    }

private:
    std::map<std::string, std::shared_ptr<image> > cache;
};
\end{minted}
\caption{Пример (некорректный) кеша изображений}
\label{listing:shared_ptr_image_cache_broken}
\end{listing}

Однако использование \mintinline{c++}{shared_ptr<image>} в кеше приводит к проблеме. \mintinline{c++}{shared_ptr} мешает \mintinline{c++}{image}'ам удаляться, поскольку на все \mintinline{c++}{image}'ы как минимум держатся ссылки из кеша. В результате все загруженные изображения будут удерживаться, пока живет \mintinline{c++}{image_cache}.

Для решения этой задачи требуется класс который позволяет ссылаться на \mintinline{c++}{image}, но не удерживать ссылку на него. Таким классом является \mintinline{c++}{std::weak_ptr}. \mintinline{c++}{weak_ptr} используется совместно с \mintinline{c++}{shared_ptr} и позволяет ссылаться на объект не препятствуя его удалению.

\mintinline{c++}{weak_ptr} имеет следующие операции:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
struct weak_ptr
{
    // создает weak_ptr не ссылающийся ни на один объект
    weak_ptr();
    // создает weak_ptr ссылающийся на тот же объект, что и sp
    weak_ptr(shared_ptr<T> const& sp);

    weak_ptr(weak_ptr const& other);
    weak_ptr& operator=(weak_ptr const& other);

    // Возвращает нулевой shared_ptr, если объект был удалён
    // Возвращает ненулевой shared_ptr, если объект ещё не был удален
    shared_ptr<T> lock() const;
};
\end{minted}

\mintinline{c++}{weak_ptr} не имеет операции разыменования.

С использованием \mintinline{c++}{weak_ptr} пример \ref{listing:shared_ptr_image_cache_broken} можно переписать следующим образом:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct image_cache
{
    image_cache(image_cache const&) = delete;
    image_cache& operator=(image_cache const&) = delete;

    std::shared_ptr<image> load_image(std::string const& name)
    {
        auto i = cache.find(name);
        if (i != cache.end())
        {
            std::shared_ptr<image> p = i->second.lock();
            if (p)
                return p;
        }
            
        std::shared_ptr<image> p = real_load_image(name);
        cache[name] = p;
        return p;
    }

private:
    std::map<std::string, std::weak_ptr<image> > cache;
};
\end{minted}

Для поддержки \mintinline{c++}{weak_ptr}, \mintinline{c++}{shared_count} содержит два счетчика ссылок: один для обычных (сильных) ссылок и один для слабых ссылок. Достижение счетчика сильных нуля влечет удаление управляемого объекта, достичение обоих счетчиков нуля влечет удаление \mintinline{c++}{shared_count}'а.

\subsection{Приведение умных указателей}

Встроенные операторы приведения типа \mintinline{c++}{static_cast}, \mintinline{c++}{dynamic_cast}, \mintinline{c++}{reinterpret_cast}, \mintinline{c++}{const_cast} определены для обычных указателей. Для умных они либо не работают (\mintinline{c++}{dynamic_cast}, \mintinline{c++}{reinterpret_cast}, \mintinline{c++}{const_cast}), либо делают другую операцию (\mintinline{c++}{static_cast}).

Что делать если существует например \mintinline{c++}{shared_ptr<B>} и ему требуется сделать \mintinline{c++}{dynamic_cast} к \mintinline{c++}{shared_ptr<D>}? Наивная попытка могла бы выглядеть следующим образом:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
shared_ptr<B> base;
shared_ptr<D> derived = shared_ptr<D>(dynamic_cast<D*>(base.get()));
\end{minted}

Однако данный код приводит к разделению счетчика ссылок (\ref{reference_counter_split_problem}). Чтобы не разделять счетчик ссылок следует использовать aliasing конструктор (\ref{aliasing_constructor}):

\begin{listing}
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
shared_ptr<B> base;
shared_ptr<D> derived = shared_ptr<D>(base, dynamic_cast<D*>(base.get()));
\end{minted}
\caption{Использование aliasing конструктора для \mintinline{c++}{dynamic_cast}'а \mintinline{c++}{shared_ptr}'ов}
\label{listing:downcasting_using_aliasing_constructor}
\end{listing}

В стандартной библиотеке существуют функции использующие aliasing конструктор и делающие приведение типов. Они называются \mintinline{c++}{static_pointer_cast}, \mintinline{c++}{dynamic_pointer_cast} и \mintinline{c++}{const_pointer_cast}. \mintinline{c++}{reinterpret_pointer_cast} присутствует в библиотеке Boost, но по какой-то причине отсутствует в стандартной библиотеке.

С использованием \mintinline{c++}{dynamic_pointer_cast} пример \ref{listing:downcasting_using_aliasing_constructor} может быть переписан следующим образом:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
shared_ptr<B> base;
shared_ptr<D> derived = dynamic_pointer_cast<D>(base);
\end{minted}

\subsection{\mintinline{c++}{linked_ptr}}

\mintinline{c++}{linked_ptr} --- умный указатель с разделяемым владением, реализованный с помощью двусвязного списка.\\
\mintinline{c++}{linked_ptr} хранит в себе указатель на объект и два указателя на соседние \mintinline{c++}{linked_ptr}'ы в двусвязном списке. Для каждого двусвязного списка образованного из \mintinline{c++}{linked_ptr}'ов верно, что все указатели в нём владеют одним общим объектом.

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template <class T> struct linked_ptr
{
    ...
private:
    T* ptr;
    mutable linked_ptr* prev; 
    mutable linked_ptr* next; 
};
\end{minted}
Члены prev и next помечены как \mintinline{c++}{mutable}, потому что в случае если мы имеем константный \mintinline{c++}{const linked_ptr& p1}, который передается в функцию, и неконстантный \mintinline{c++}{linked_ptr& p2}, который является его соседом в двусвязном списке, то при изменении p1 придется поменять prev и next у p2.\\
Так, например, может выглядеть фрагмент двусвязного списка, образованного \mintinline{c++}{linked_ptr}'ами ptr1, ptr2, ptr3, указывающими на общий объект object:\\

\begin{minipage}[h]{0.4\linewidth}
\centering
\begin{asy}
real arrow_len = 5;
real box_h = arrow_len / 3.0;
real box_w = box_h;
real box_count = 3;
real object_box_w = 2 * box_w;

real get_x0(int i) {
    return arrow_len * i + box_w * (i - 1);
}

real get_x1(int i) {
    return get_x0(i) + box_w;
}

real obj_x0 = get_x0(2) - box_w / 2.0;
real obj_x1 = obj_x0 + object_box_w;
real obj_y0 = 0;
real obj_y1 = box_h;

real eps = arrow_len / 10.0;

real obj_label_x = (obj_x0 + obj_x1) / 2.0;
real obj_label_y = (obj_y0 + obj_y1) / 2.0;

real box_y0 = obj_y1 + arrow_len;
real box_y1 = box_y0 + box_h;

real box_label_x_offset = box_w / 2.0;
real box_label_y_offset = box_h / 2.0;

real arrow_left_offset = box_h * 2.0 / 3.0;
real arrow_right_offset = box_h * 1.0 / 3.0;
real arrow_left_y = box_y0 + arrow_left_offset;
real arrow_right_y = box_y0 + arrow_right_offset;
real arrow_down_offset = box_w * 0.5;

real label_offset = box_h / 6.0;
size(15cm,0);

void draw_arrow(path p, real relative_pos, string text, align al) {
    draw(
        L=Label(
            scale(0.5)*("" + text + ""),
            position=Relative(relative_pos),
            gray,
            align = al
        ),
        p,
        arrow=Arrow
    );
}

void draw_strait_arrows(real x0, real x1, real len = arrow_len) {
    real rel_pos = 0.75 + 0.22 * (1 - arrow_len / len);
    draw_arrow((x0 - len, arrow_left_y) -- (x0, arrow_left_y), rel_pos, "next", (E + N / 2.0));
    draw_arrow((x0, arrow_right_y) -- (x0 - len, arrow_right_y), rel_pos, "prev", (W - N / 2.0));
}

void draw_curved_arrow(pair p0, pair p3, string text, bool reversed = false) {
    real delta = arrow_len * (1.0 / 3.0);
    pair p1 = (xpart(p0) + delta, ypart(p0));
    pair p2 = (xpart(p3) - delta, ypart(p3));
    pair add = (arrow_len / 10.0, 0);
    if (reversed) {
        p1 -= add;
        p2 -= add - (0, box_h / 10.0);
    } else {
        p1 += add - (0, box_h / 10.0);
        p2 += add;
    }
    p2 += 0.3 * (p1 - p2);
    p1 -= 0.3 * (p1 - p2);
    pair p1_5 = (p1 + p2) / 2.0;

    //draw(circle(p1, 0.1), red);
    //draw(circle(p1_5, 0.1), magenta);
    //draw(circle(p2, 0.1), blue);

    path p = p0{right}..{down}p1{down}..{left}p1_5{left}..{down}p2{down}..{right}p3;
    draw_arrow(reversed ? reverse(p) : p, 0.938, text, reversed ? N : -N);

    pair q0 = p3 + box_w, q1 = p2 + (box_w + 2 * (xpart(p3) - xpart(p2)), 0), q3 = p0 + arrow_len, q2 = p1 + (arrow_len - 2 * (xpart(p1) - xpart(p0)), 0);
    pair q1_5 = (q1 + q2) / 2.0;

    //draw(circle(q1, 0.1), red);
    //draw(circle(q1_5, 0.1), magenta);
    //draw(circle(q2, 0.1), blue);

    p = q0{right}..{up}q1{up}..{left}q1_5{left}..{up}q2{up}..{right}q3;
    draw_arrow(reversed ? reverse(p) : p, 0.938, text, reversed ? N : -N);
}

void draw_arrow_to_obj(real x0, real y0) {
    pair p0 = (x0, y0);
    real obj_mid = (obj_x0 + obj_x1) / 2.0;
    pair p1 = (obj_mid + (x0 - obj_mid) / 1.5, obj_y1 + arrow_len / 2.0 - abs(x0 - obj_mid) / 7.0);
    pair p2 = (obj_mid+ (x0 - obj_mid) / 50.0, obj_y1);
    if (x0 == obj_mid) {
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.7),
                gray,
                align=-N + W * 0.7
            ),
            p0 -- p2,
            arrow=Arrow
        );
    } else if (x0 < obj_mid) 
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.6),
                gray,
                align=-N
            ),
            p0{down}..{right}p1{right}..{down}p2,
            arrow=Arrow
        );
    else
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.5),
                gray,
                align=-N
            ),
            p0{down}..{left}p1{left}..{down}p2,
            arrow=Arrow
        );
}

void draw_box(real x0, real x1, int i, real y0 = box_y0, real y1 = box_y1, pen color=royalblue) {
    draw_arrow_to_obj(x0 + arrow_down_offset, y0);
    path ptr = box((x0, y0), (x1, y1));
    fill(ptr, color);
    draw(ptr, black);
    label("ptr" + string(i) + "", (x0 + box_label_x_offset, y0 + box_label_y_offset), white);
}

void draw_last_arrows() {
    int last_index = (int)box_count + 1;
    real last_x0 = get_x0(last_index) - arrow_len / 2;
    real last_x1 = get_x1(last_index) - arrow_len / 2;
    draw_strait_arrows(last_x0, last_x1, arrow_len / 2);
}


path obj = box((obj_x0,obj_y0), (obj_x1,obj_y1));
fill(obj, deepgreen);
draw(obj, black);
label("object", (obj_label_x, obj_label_y), white);


for (int i = 1; i <= box_count; ++i) {
    real x0 = get_x0(i), x1 = get_x1(i);
    draw_strait_arrows(x0, x1, i == 1 ? arrow_len / 2 : arrow_len);
    draw_box(x0, x1, i);
}
draw_last_arrows();
\end{asy}
\label{fig:prob1_6_2}
\end{minipage}

При копировании \mintinline{c++}{linked_ptr<int> ptr4 = ptr2;} новый ptr4 вставляется в тот же список, где был исходный ptr2. После выполнения этой операции двусвязный список указателей будет выглядеть следующим образом:\\

\begin{minipage}[h]{0.4\linewidth}
\centering
\begin{asy}
real arrow_len = 5;
real box_h = arrow_len / 3.0;
real box_w = box_h;
real box_count = 3;
real object_box_w = 2 * box_w;

real get_x0(int i) {
    return arrow_len * i + box_w * (i - 1);
}

real get_x1(int i) {
    return get_x0(i) + box_w;
}

real obj_x0 = get_x0(2) - box_w / 2.0;
real obj_x1 = obj_x0 + object_box_w;
real obj_y0 = 0;
real obj_y1 = box_h;

real eps = arrow_len / 10.0;

real obj_label_x = (obj_x0 + obj_x1) / 2.0;
real obj_label_y = (obj_y0 + obj_y1) / 2.0;

real box_y0 = obj_y1 + arrow_len;
real box_y1 = box_y0 + box_h;

real box_label_x_offset = box_w / 2.0;
real box_label_y_offset = box_h / 2.0;

real arrow_left_offset = box_h * 2.0 / 3.0;
real arrow_right_offset = box_h * 1.0 / 3.0;
real arrow_left_y = box_y0 + arrow_left_offset;
real arrow_right_y = box_y0 + arrow_right_offset;
real arrow_down_offset = box_w * 0.5;

real label_offset = box_h / 6.0;
size(15cm,0);

void draw_arrow(path p, real relative_pos, string text, align al) {
    draw(
        L=Label(
            scale(0.5)*("" + text + ""),
            position=Relative(relative_pos),
            gray,
            align = al
        ),
        p,
        arrow=Arrow
    );
}

void draw_strait_arrows(real x0, real x1, real len = arrow_len) {
    real rel_pos = 0.75 + 0.22 * (1 - arrow_len / len);
    draw_arrow((x0 - len, arrow_left_y) -- (x0, arrow_left_y), rel_pos, "next", (E + N / 2.0));
    draw_arrow((x0, arrow_right_y) -- (x0 - len, arrow_right_y), rel_pos, "prev", (W - N / 2.0));
}

void draw_curved_arrow(pair p0, pair p3, string text, bool reversed = false) {
    real delta = arrow_len * (1.0 / 3.0);
    pair p1 = (xpart(p0) + delta, ypart(p0));
    pair p2 = (xpart(p3) - delta, ypart(p3));
    pair add = (arrow_len / 10.0, 0);
    if (reversed) {
        p1 -= add;
        p2 -= add - (0, box_h / 10.0);
    } else {
        p1 += add - (0, box_h / 10.0);
        p2 += add;
    }
    p2 += 0.3 * (p1 - p2);
    p1 -= 0.3 * (p1 - p2);
    pair p1_5 = (p1 + p2) / 2.0;

    //draw(circle(p1, 0.1), red);
    //draw(circle(p1_5, 0.1), magenta);
    //draw(circle(p2, 0.1), blue);

    path p = p0{right}..{down}p1{down}..{left}p1_5{left}..{down}p2{down}..{right}p3;
    draw_arrow(reversed ? reverse(p) : p, 0.938, text, reversed ? N : -N);

    pair q0 = p3 + box_w, q1 = p2 + (box_w + 2 * (xpart(p3) - xpart(p2)), 0), q3 = p0 + arrow_len, q2 = p1 + (arrow_len - 2 * (xpart(p1) - xpart(p0)), 0);
    pair q1_5 = (q1 + q2) / 2.0;

    //draw(circle(q1, 0.1), red);
    //draw(circle(q1_5, 0.1), magenta);
    //draw(circle(q2, 0.1), blue);

    p = q0{right}..{up}q1{up}..{left}q1_5{left}..{up}q2{up}..{right}q3;
    draw_arrow(reversed ? reverse(p) : p, 0.938, text, reversed ? N : -N);
}

void draw_arrow_to_obj(real x0, real y0) {
    pair p0 = (x0, y0);
    real obj_mid = (obj_x0 + obj_x1) / 2.0;
    pair p1 = (obj_mid + (x0 - obj_mid) / 1.5, obj_y1 + arrow_len / 2.0 - abs(x0 - obj_mid) / 7.0);
    pair p2 = (obj_mid+ (x0 - obj_mid) / 50.0, obj_y1);
    if (x0 == obj_mid) {
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.6),
                gray,
                align=-N + W * 0.7
            ),
            p0 -- p2,
            arrow=Arrow
        );
    } else if (x0 < obj_mid) 
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.5),
                gray,
                align=-N
            ),
            p0{down}..{right}p1{right}..{down}p2,
            arrow=Arrow
        );
    else
        draw(
            L=Label(
                scale(0.5)*"ptr",
                position=Relative(0.5),
                gray,
                align=-N
            ),
            p0{down}..{left}p1{left}..{down}p2,
            arrow=Arrow
        );
}

void draw_box(real x0, real x1, int i, real y0 = box_y0, real y1 = box_y1, pen color=royalblue) {
    draw_arrow_to_obj(x0 + arrow_down_offset, y0);
    path ptr = box((x0, y0), (x1, y1));
    fill(ptr, color);
    draw(ptr, black);
    label("ptr" + string(i) + "", (x0 + box_label_x_offset, y0 + box_label_y_offset), white);
}

void draw_last_arrows() {
    int last_index = (int)box_count + 1;
    real last_x0 = get_x0(last_index) - arrow_len / 2;
    real last_x1 = get_x1(last_index) - arrow_len / 2;
    draw_strait_arrows(last_x0, last_x1, arrow_len / 2);
}


path obj = box((obj_x0,obj_y0), (obj_x1,obj_y1));
fill(obj, deepgreen);
draw(obj, black);
label("object", (obj_label_x, obj_label_y), white);


for (int i = 1; i <= 2; ++i) {
    real x0 = get_x0(i), x1 = get_x1(i);
    draw_strait_arrows(x0, x1, i == 1 ? arrow_len / 2 : arrow_len);
    draw_box(x0, x1, i);
}
draw_last_arrows();

real x2_0 = get_x0(2), x2_1 = get_x1(2), x3_0 = get_x0(3), x3_1 = get_x1(3);
real x4_0 = x2_1 + (arrow_len - box_w) / 2.0;
real x4_1 = x4_0 + box_w;
real y4_0 = box_y0 - arrow_len / 2.0;
real y4_1 = y4_0 + box_h;

draw_box(x3_0, x3_1, 3);

draw_box(x4_0, x4_1, 4, y4_0, y4_1, brown);

draw_curved_arrow((x2_1, arrow_left_y), (x4_0, y4_0 + arrow_left_offset), "next", false);
draw_curved_arrow((x2_1, arrow_right_y), (x4_0, y4_0 + arrow_right_offset), "prev", true);

//draw_curved_arrow((x4_1, y4_0 + arrow_left_offset), (x3_0, arrow_left_y), "next", false);
//draw_curved_arrow((x4_1, y4_0 + arrow_right_offset), (x3_0, arrow_right_y), "prev", true);
\end{asy}
\label{fig:prob1_6_2}
\end{minipage}

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
linked_ptr(linked_ptr const& other) noexcept
    : ptr(other.ptr)
{
    if (ptr == nullptr) {
        prev = next = nullptr;
        return;
    }
    prev = &other;
    next = other.next;
    prev->next = this;
    next->prev = this;
}
\end{minted}

При удалении \mintinline{c++}{linked_ptr} он удаляется из двусвязного списка. Если он был единственным элементом списка то он удаляет сам объект:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}

~linked_ptr() noexcept 
{
    if (!ptr) return;
    if (prev == this)
        delete ptr;
    if (prev) prev->next = next;
    if (next) next->prev = prev;
}

\end{minted}

Move-конструктор у \mintinline{c++}{linked_ptr} может выглядеть следующим образом:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
linked_ptr(linked_ptr&& other) noexcept
    : ptr(other.ptr)
    , prev(other.prev)
    , next(other.next)
{
    other.prev = other.next = nullptr;
    other.ptr = nullptr;
    if (this->prev) 
        this->prev->next = this;
    if (this->next) 
        this->next->prev = this;
}
\end{minted}
Заметим, что в отличае от конструктора копирования нужно занулять члены other, потому что на нем будет вызван деструктор.

\mintinline{c++}{linked_ptr} реализует операции \mintinline{c++}{get()}, \mintinline{c++}{operator*} и \mintinline{c++}{operator->}, как и другие умные указатели:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
T* get() const noexcept { return ptr; } // разыменование указателя
T* operator->() const noexcept { return ptr; } // вызов мембера объекта, на который указывает linked_ptr
T& operator*() const { return *ptr; }
\end{minted}

\subsubsection{сравнение \mintinline{c++}{linked_ptr} и \mintinline{c++}{shared_ptr}}

\begin{enumerate}
\item При инициализации \mintinline{c++}{std::shared_ptr} сырым указателем, \mintinline{c++}{std::shared_ptr} аллоцирует дополнительный объект в куче для счетчика ссылок. \mintinline{c++}{linked_ptr} не аллоцирует дополнительной памяти.
\item \mintinline{c++}{linked_ptr} имеет больший размер, чем \mintinline{c++}{shared_ptr} --- три указателя, вместо двух у \mintinline{c++}{shared_ptr}.
\item \mintinline{c++}{std::shared_ptr} в стандартной библиотеке является thread-safe. Он использует атомарные операции инкремента и декремента для счетчика ссылок. Thread-safe \mintinline{c++}{linked_ptr} не может быть так просто реализован.
\item \mintinline{c++}{linked_ptr} также имеет внутри больше присваиваний и сравнений на каждую операцию копирования и присваивания, в то время как \mintinline{c++}{std::shared_ptr} лишь инкрементирует счетчик.
\end{enumerate}

\subsection{\mintinline{c++}{intrusive_ptr}}

\mintinline{c++}{intrusive_ptr} --- умный указатель с разделяемым владением, реализованный в библиотеке Boost. Так же как и \mintinline{c++}{std::shared_ptr}, он использует подсчет ссылок, но в отличии от \mintinline{c++}{std::shared_ptr} в \mintinline{c++}{boost::intrusive_ptr<T>} счетчик ссылок хранится в самом объекте класса T, на который он ссылается.

Для использования \mintinline{c++}{intrusive_ptr} с пользовательским типом \mintinline{c++}{mytype} требуется реализовать две функции:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
void intrusive_ptr_add_ref(mytype* p);
void intrusive_ptr_release(mytype* p);
\end{minted}

Функция \mintinline{c++}{intrusive_ptr_add_ref} вызывается, когда требуется увеличить счетчик ссылок. Функция \mintinline{c++}{intrusive_ptr_release} вызывается тогда, когда требуется его уменьшить и если он достигает нуля, то требуется самостоятельно удалить объект.

Пример использования:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
#include <boost/intrusive_ptr.hpp>

class Test {
public:
    int ref_count;
};

void intrusive_ptr_add_ref(Test *p) {
    ++p->ref_count;
}

void intrusive_ptr_release(Test *p) {
    if (0 == --p->ref_count)
        delete p;
}

int main() {
    boost::intrusive_ptr<Test> p(new Test()); // аллоцированный объект, переданный в конструктор будет удален при выходе из main
}
\end{minted}

Замечание: \mintinline{c++}{boost::intrusive_ptr} эффективнее \mintinline{c++}{std::shared_ptr}, поскольку пользователь сам может встроить эффективный счетчик ссылок для своего объекта. Причем контракт функций \mintinline{c++}{intrusive_ptr_add_ref} и \mintinline{c++}{intrusive_ptr_release} такой, что они не накладывают строгие ограничения на счетчик ссылок, кроме того, что \mintinline{c++}{intrusive_ptr_release} должен удалить объект, когда удаляется последний его владелец. Поэтому если планируется использование разделяемого smart-pointer’а для класса, реализуемого самим пользователем, то лучше юзать \mintinline{c++}{intrusive_ptr}, а в случае если приходится иметь дело с библиотечным классом, то \mintinline{c++}{std::shared_ptr}.

\subsection{make\_shared / make\_unique}

Как было сказано ранее, помимо стандартных конструкторов от указателя стандарт предлагает фабрики для создания объектов, определенные следующим образом (рассмотрим на примере \mintinline{c++}{std::shared_ptr}): 

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args); // создает std::shared_ptr<T>, указывающий на объект T(args...)
\end{minted}
Исторически введение данного метода должно было решить проблему производительности \mintinline{c++}{std::shared_ptr}, аллоцируя внутри только один объект, содержащий одновременно и счетчик ссылок и объект типа T. Причем при вызове \mintinline{c++}{std::make_shared(args...)} на новом объекте типа T сразу вызовется конструктор с переданными аргументами. Таким образом такой конструктор-фабрика экономит аллокации памяти (вместо двух аллокаций: \mintinline{c++}{new T(args...)} и \mintinline{c++}{new counter()} происходит одна аллокация данных для пары (\mintinline{c++}{object}, \mintinline{c++}{counter}).

Также введение такой функции в стандарт позволило решить проблему с гарантиями безопасности. Представим следующую ситуацию:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
f(std::shared_ptr<Class>(new Class("class")), g());
\end{minted}

При этом \mintinline{c++}{g()} бросает исключение. так как по стандарту нет гарантии порядка вычисления аргументов \mintinline{c++}{f}, то может произойти следующее: сначала создадим \mintinline{c++}{new Class()}, выделим память, потом --- вызовем \mintinline{c++}{g()}, которое бросит исключение, после чего конструктор \mintinline{c++}{shared_ptr} уже не вызовется, так как бросился exception. А так как мы нигде не пишем слово \mintinline{c++}{delete}, то произойдет memory leak.

Теперь рассмотрим случай с \mintinline{c++}{make_shared}: 

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}
f(std::make_shared<Class>("class"), g());
\end{minted}

Если сначала вызовется \mintinline{c++}{g()}, то до конструктора \mintinline{c++}{Class} дело вообще не дойдет и упомянутой проблемы не возникнет. С другой стороны, если сначала вызовется \mintinline{c++}{make_shared}, то объект будет уже обернут в smart pointer и после исключения в \mintinline{c++}{g()} он будет автоматически удален!!!

Начиная с c++14 аналогичная функция-фабрика \mintinline{c++}{std::make_unique} была добавлена и для \mintinline{c++}{std::unique_ptr}. Это позволило не использовать в коде не только \mintinline{c++}{delete}, но и голый \mintinline{c++}{new} (no naked new) для обоих видов умных указателей, включенных в стандартную библиотеку.

\subsection{Smart pointers pointing on this}

Особый случай, когда нельзя неосторожно использовать умные указатели --- это наличие указателей на this, которые возвращает метод класса. Рассмотрим код:

\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}

class SomeClass {
    int data = 5;
    std::shared_ptr<SomeClass> f() {
        return std::shared_ptr<SomeClass>(this);
    }
    void foo() {}
}

SomeClass obj;

if (true) { // some scope
    auto ptr = ob.f();
} // exit scope (*)
obj.foo();

\end{minted}

В этом примере при выхода из области видимости (*) так как умный указатель на obj создан всего один, он вызовет деструктор \mintinline{c++}{obj}. Но при этом после этого мы уже не сможем его использовать (\mintinline{c++}{obj.foo()} уже некорректно). Поэтому для таких целей в стандартной библиотеке есть интерфейс \mintinline{c++}{std::enable_shared_from_this}, который позволяет держать сильную ссылку на себя внутри самого объекта класса, который от него унаследован. В нашем случае:


\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}

class SomeClass: std::enable_shared_from_this<SomeClass> {
    int data = 5;
    std::shared_ptr<SomeClass> f() {
        return std::shared_ptr<SomeClass>(this);
    }
    void foo() {}
}


SomeClass obj;


if (true) { 
    auto ptr = ob.f();
} 
obj.foo();

\end{minted}

Такой код будет уже корректный. Таким образом использование интерфейса \mintinline{c++}{std::enable_shared_from_this} позволяет избежать проблемы сплита указателей.

\subsection{smart pointers и наследование}

В стандартной библиотеке умные указатели сделаны так, что если присваивания объекта типа \mintinline{c++}{A} может быть произведено в объект типа \mintinline{c++}{B}, то присваивания объекта типа \mintinline{c++}{smart_pointer<A>} может быть произведено в объект типа \mintinline{c++}{smart_pointer<B>}.
В том числе:
 
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}

shared_ptr<Derived> dp1(new Derived); 
shared_ptr<Base> bp1 = dp1; 
shared_ptr<Base> bp2(dp1); 
shared_ptr<Base> bp3(new Derived);

\end{minted}
Это корректный код. Но стоит отметить, что в этом случае так как указатель внутри будет хранится на \mintinline{c++}{Derived} объект, то деструктор будет вызван ровно его. Поэтому если он не объявлен как виртуальный, то это UB.
Для явного каста указателей в стандартной библиотеке есть специальные методы:
\begin{minted}[
linenos,
frame=lines,
framesep=2mm]
{c++}

derived_ptr = static_pointer_cast<Derived>(base_ptr);

\end{minted}
Этот стейтмент валиден тогда и только тогда, когда \mintinline{c++}{static_cast<Derived *>(base_ptr.get())} --- валидно, так как ровно на его основе метод \mintinline{c++}{static_pointer_cast} реализован. Использование \mintinline{c++}{static_pointer_cast} помогает избавиться от типичной ошибки --- использования \mintinline{c++}{static_cast<Derived*>(base_ptr.get())} в явном виде, приводящего к split'у умных указателей.

\subsection{доп. функции}
\begin{enumerate}
\item Умные указатели умеют каститься к \mintinline{c++}{bool} (\mintinline{c++}{true} тогда и только тогда, когда указываемый объект не \mintinline{c++}{nullptr})
\item  Также для них определены операции сравнения \mintinline{c++}{==}, \mintinline{c++}{!=}, \mintinline{c++}{<}, которые сравнивают голые указатели внутри.
\end{enumerate}

\subsection{Performance test}

Также уместно представить сравнение производительностей разных видов указателей. На графиках ниже по оси OY отмечено среднее время соответствующих операций над умными указателями. Это время приведено в тактах процессора (для измерений использовался Intel Core i5-5257U). Также отмечена дисперсия каждого из измерений.    

\begin{minipage}[h]{0.4\linewidth}
\centering
\begin{asy}
real linked = 221;
real shared = 572;
real intrusive = 214;
real unique = 239;
real linked_disp = 0;
real shared_disp = 2;
real intrusive_disp = 8;
real unique_disp = 6;real bench_width = 312.0;
real max_height = 572;

real arrow_offset = bench_width / 4.0 * 1.1;
real point_offset = arrow_offset * 2 / 3;
real linked_offset = arrow_offset + bench_width;
real shared_offset = arrow_offset + 2 * bench_width;
real intrusive_offset = arrow_offset + 3 * bench_width;
real unique_offset = arrow_offset + 4 * bench_width;
real label_offset = (shared_offset - linked_offset) / 2.0;

size(20cm,0);
draw((arrow_offset / 2, 0) -- (arrow_offset / 2, max_height),arrow=Arrow);

label(
    scale(0.5) * ("" + string(linked) + ""),
    (point_offset, linked),
    black
);
label(
    scale(0.5) * ("" + string(shared) + ""),
    (point_offset, shared),
    black
);
label(
    scale(0.5) * ("" + string(intrusive) + ""),
    (point_offset, intrusive),
    black
);
label(
    scale(0.5) * ("" + string(unique) + ""),
    (point_offset, unique),
    black
);
path lin = box((arrow_offset,0), (linked_offset,linked));
fill(lin, deepgreen);

path sha = box((linked_offset,0), (shared_offset,shared));
fill(sha, royalblue);

path intr = box((shared_offset,0), (intrusive_offset,intrusive));
fill(intr, magenta);

path uniq = box((intrusive_offset,0), (unique_offset,unique));
fill(uniq, heavyred);

real disp_eps = bench_width / 20.0;
draw(
    (arrow_offset, linked) 
    -- (arrow_offset, linked + linked_disp) 
    -- (arrow_offset + disp_eps, linked + linked_disp) 
    -- (arrow_offset - disp_eps, linked + linked_disp) 
    -- (arrow_offset, linked + linked_disp)
    -- (arrow_offset, linked - linked_disp)
    -- (arrow_offset + disp_eps, linked - linked_disp) 
    -- (arrow_offset - disp_eps, linked - linked_disp) 
    -- (arrow_offset, linked - linked_disp)
, gray);
draw(
    (linked_offset, shared) 
    -- (linked_offset, shared + shared_disp) 
    -- (linked_offset + disp_eps, shared + shared_disp) 
    -- (linked_offset - disp_eps, shared + shared_disp) 
    -- (linked_offset, shared + shared_disp)
    -- (linked_offset, shared - shared_disp)
    -- (linked_offset + disp_eps, shared - shared_disp) 
    -- (linked_offset - disp_eps, shared - shared_disp) 
    -- (linked_offset, shared - shared_disp)
, gray);
draw(
    (shared_offset, intrusive) 
    -- (shared_offset, intrusive + intrusive_disp) 
    -- (shared_offset + disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset, intrusive + intrusive_disp)
    -- (shared_offset, intrusive - intrusive_disp)
    -- (shared_offset + disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset, intrusive - intrusive_disp)
, gray);
draw(
    (intrusive_offset, unique) 
    -- (intrusive_offset, unique + unique_disp) 
    -- (intrusive_offset + disp_eps, unique + unique_disp) 
    -- (intrusive_offset - disp_eps, unique + unique_disp) 
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset, unique - unique_disp)
    -- (intrusive_offset + disp_eps, unique - unique_disp) 
    -- (intrusive_offset - disp_eps, unique - unique_disp) 
    -- (intrusive_offset, unique - unique_disp)
, gray);

real label_delta = 0.05 * max(max(linked, shared), max(intrusive, unique));
label("linked\underline{\hspace{0.3cm}}ptr", (linked_offset - label_offset, linked + label_delta), black);
label("std::shared\underline{\hspace{0.3cm}}ptr", (shared_offset - label_offset, shared + label_delta), black);
label("boost::intruisive\underline{\hspace{0.3cm}}ptr", (intrusive_offset - label_offset, intrusive + label_delta), black);
label("std::unique\underline{\hspace{0.3cm}}ptr", (unique_offset - label_offset, unique + label_delta), black);
label("allocation/deallocation benchmark : ", (bench_width * 2.0, max_height * 1.1));
real linked = 178;
real shared = 357;
real intrusive = 195;
real unique = 178;
real linked_disp = 4;
real shared_disp = 9;
real intrusive_disp = 3;
real unique_disp = 4;path lin = box((arrow_offset,0), (linked_offset,linked));
fill(lin, black);

path sha = box((linked_offset,0), (shared_offset,shared));
fill(sha, black);

path intr = box((shared_offset,0), (intrusive_offset,intrusive));
fill(intr, black);

path uniq = box((intrusive_offset,0), (unique_offset,unique));
fill(uniq, black);

real disp_eps = bench_width / 20.0;
draw(
    (arrow_offset, linked) 
    -- (arrow_offset, linked + linked_disp) 
    -- (arrow_offset + disp_eps, linked + linked_disp) 
    -- (arrow_offset - disp_eps, linked + linked_disp) 
    -- (arrow_offset, linked + linked_disp)
    -- (arrow_offset, linked - linked_disp)
    -- (arrow_offset + disp_eps, linked - linked_disp) 
    -- (arrow_offset - disp_eps, linked - linked_disp) 
    -- (arrow_offset, linked - linked_disp)
, gray);
draw(
    (linked_offset, shared) 
    -- (linked_offset, shared + shared_disp) 
    -- (linked_offset + disp_eps, shared + shared_disp) 
    -- (linked_offset - disp_eps, shared + shared_disp) 
    -- (linked_offset, shared + shared_disp)
    -- (linked_offset, shared - shared_disp)
    -- (linked_offset + disp_eps, shared - shared_disp) 
    -- (linked_offset - disp_eps, shared - shared_disp) 
    -- (linked_offset, shared - shared_disp)
, gray);
draw(
    (shared_offset, intrusive) 
    -- (shared_offset, intrusive + intrusive_disp) 
    -- (shared_offset + disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset, intrusive + intrusive_disp)
    -- (shared_offset, intrusive - intrusive_disp)
    -- (shared_offset + disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset, intrusive - intrusive_disp)
, gray);
draw(
    (intrusive_offset, unique) 
    -- (intrusive_offset, unique + unique_disp) 
    -- (intrusive_offset + disp_eps, unique + unique_disp) 
    -- (intrusive_offset - disp_eps, unique + unique_disp) 
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset, unique - unique_disp)
    -- (intrusive_offset + disp_eps, unique - unique_disp) 
    -- (intrusive_offset - disp_eps, unique - unique_disp) 
    -- (intrusive_offset, unique - unique_disp)
, gray);

real label_heigth=bench_width / 4.0;
label("heap allocation", (linked_offset - label_offset, label_heigth), white);
label("heap allocation", (shared_offset - label_offset, label_heigth), white);
label("heap allocation", (intrusive_offset - label_offset, label_heigth), white);
label("heap allocation", (unique_offset - label_offset, label_heigth), white);
\end{asy}
\end{minipage}

\begin{minipage}[h]{0.4\linewidth}
\begin{asy}
real linked = 12;
real shared = 48;
real intrusive = 10;
real unique = 0;
real linked_disp = 0;
real shared_disp = 0;
real intrusive_disp = 0;
real unique_disp = 0;real bench_width = 18.0;
real max_height = 48;

real arrow_offset = bench_width / 4.0 * 1.1;
real point_offset = arrow_offset * 2 / 3;
real linked_offset = arrow_offset + bench_width;
real shared_offset = arrow_offset + 2 * bench_width;
real intrusive_offset = arrow_offset + 3 * bench_width;
real unique_offset = arrow_offset + 4 * bench_width;
real label_offset = (shared_offset - linked_offset) / 2.0;

size(20cm,0);
draw((arrow_offset / 2, 0) -- (arrow_offset / 2, max_height),arrow=Arrow);

label(
    scale(0.5) * ("" + string(linked) + ""),
    (point_offset, linked),
    black
);
label(
    scale(0.5) * ("" + string(shared) + ""),
    (point_offset, shared),
    black
);
label(
    scale(0.5) * ("" + string(intrusive) + ""),
    (point_offset, intrusive),
    black
);
label(
    scale(0.5) * ("" + string(unique) + ""),
    (point_offset, unique),
    black
);
path lin = box((arrow_offset,0), (linked_offset,linked));
fill(lin, deepgreen);

path sha = box((linked_offset,0), (shared_offset,shared));
fill(sha, royalblue);

path intr = box((shared_offset,0), (intrusive_offset,intrusive));
fill(intr, magenta);

path uniq = box((intrusive_offset,0), (unique_offset,unique));
fill(uniq, heavyred);

real disp_eps = bench_width / 20.0;
draw(
    (arrow_offset, linked) 
    -- (arrow_offset, linked + linked_disp) 
    -- (arrow_offset + disp_eps, linked + linked_disp) 
    -- (arrow_offset - disp_eps, linked + linked_disp) 
    -- (arrow_offset, linked + linked_disp)
    -- (arrow_offset, linked - linked_disp)
    -- (arrow_offset + disp_eps, linked - linked_disp) 
    -- (arrow_offset - disp_eps, linked - linked_disp) 
    -- (arrow_offset, linked - linked_disp)
, gray);
draw(
    (linked_offset, shared) 
    -- (linked_offset, shared + shared_disp) 
    -- (linked_offset + disp_eps, shared + shared_disp) 
    -- (linked_offset - disp_eps, shared + shared_disp) 
    -- (linked_offset, shared + shared_disp)
    -- (linked_offset, shared - shared_disp)
    -- (linked_offset + disp_eps, shared - shared_disp) 
    -- (linked_offset - disp_eps, shared - shared_disp) 
    -- (linked_offset, shared - shared_disp)
, gray);
draw(
    (shared_offset, intrusive) 
    -- (shared_offset, intrusive + intrusive_disp) 
    -- (shared_offset + disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset, intrusive + intrusive_disp)
    -- (shared_offset, intrusive - intrusive_disp)
    -- (shared_offset + disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset, intrusive - intrusive_disp)
, gray);
draw(
    (intrusive_offset, unique) 
    -- (intrusive_offset, unique + unique_disp) 
    -- (intrusive_offset + disp_eps, unique + unique_disp) 
    -- (intrusive_offset - disp_eps, unique + unique_disp) 
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset, unique - unique_disp)
    -- (intrusive_offset + disp_eps, unique - unique_disp) 
    -- (intrusive_offset - disp_eps, unique - unique_disp) 
    -- (intrusive_offset, unique - unique_disp)
, gray);

real label_delta = 0.05 * max(max(linked, shared), max(intrusive, unique));
label("linked\underline{\hspace{0.3cm}}ptr", (linked_offset - label_offset, linked + label_delta), black);
label("std::shared\underline{\hspace{0.3cm}}ptr", (shared_offset - label_offset, shared + label_delta), black);
label("boost::intruisive\underline{\hspace{0.3cm}}ptr", (intrusive_offset - label_offset, intrusive + label_delta), black);
label("std::unique\underline{\hspace{0.3cm}}ptr", (unique_offset - label_offset, unique + label_delta), black);
label("copy constructor benchmark : ", (bench_width * 2.0, max_height * 1.1));
\end{asy}
\end{minipage}

\begin{minipage}[h]{0.4\linewidth}
\begin{asy}
real linked = 36;
real shared = 5;
real intrusive = 4;
real unique = 4;
real linked_disp = 0;
real shared_disp = 0;
real intrusive_disp = 0;
real unique_disp = 0;real bench_width = 12.0;
real max_height = 36;

real arrow_offset = bench_width / 4.0 * 1.1;
real point_offset = arrow_offset * 2 / 3;
real linked_offset = arrow_offset + bench_width;
real shared_offset = arrow_offset + 2 * bench_width;
real intrusive_offset = arrow_offset + 3 * bench_width;
real unique_offset = arrow_offset + 4 * bench_width;
real label_offset = (shared_offset - linked_offset) / 2.0;

size(20cm,0);
draw((arrow_offset / 2, 0) -- (arrow_offset / 2, max_height),arrow=Arrow);

label(
    scale(0.5) * ("" + string(linked) + ""),
    (point_offset, linked),
    black
);
label(
    scale(0.5) * ("" + string(shared) + ""),
    (point_offset, shared),
    black
);
label(
    scale(0.5) * ("" + string(intrusive) + ""),
    (point_offset, intrusive),
    black
);
label(
    scale(0.5) * ("" + string(unique) + ""),
    (point_offset, unique),
    black
);
path lin = box((arrow_offset,0), (linked_offset,linked));
fill(lin, deepgreen);

path sha = box((linked_offset,0), (shared_offset,shared));
fill(sha, royalblue);

path intr = box((shared_offset,0), (intrusive_offset,intrusive));
fill(intr, magenta);

path uniq = box((intrusive_offset,0), (unique_offset,unique));
fill(uniq, heavyred);

real disp_eps = bench_width / 20.0;
draw(
    (arrow_offset, linked) 
    -- (arrow_offset, linked + linked_disp) 
    -- (arrow_offset + disp_eps, linked + linked_disp) 
    -- (arrow_offset - disp_eps, linked + linked_disp) 
    -- (arrow_offset, linked + linked_disp)
    -- (arrow_offset, linked - linked_disp)
    -- (arrow_offset + disp_eps, linked - linked_disp) 
    -- (arrow_offset - disp_eps, linked - linked_disp) 
    -- (arrow_offset, linked - linked_disp)
, gray);
draw(
    (linked_offset, shared) 
    -- (linked_offset, shared + shared_disp) 
    -- (linked_offset + disp_eps, shared + shared_disp) 
    -- (linked_offset - disp_eps, shared + shared_disp) 
    -- (linked_offset, shared + shared_disp)
    -- (linked_offset, shared - shared_disp)
    -- (linked_offset + disp_eps, shared - shared_disp) 
    -- (linked_offset - disp_eps, shared - shared_disp) 
    -- (linked_offset, shared - shared_disp)
, gray);
draw(
    (shared_offset, intrusive) 
    -- (shared_offset, intrusive + intrusive_disp) 
    -- (shared_offset + disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset, intrusive + intrusive_disp)
    -- (shared_offset, intrusive - intrusive_disp)
    -- (shared_offset + disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset, intrusive - intrusive_disp)
, gray);
draw(
    (intrusive_offset, unique) 
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset + disp_eps, unique + unique_disp) 
    -- (intrusive_offset - disp_eps, unique + unique_disp)
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset, unique - unique_disp)
    -- (intrusive_offset + disp_eps, unique - unique_disp) 
    -- (intrusive_offset - disp_eps, unique - unique_disp) 
    -- (intrusive_offset, unique - unique_disp)
, gray);

real label_delta = 0.05 * max(max(linked, shared), max(intrusive, unique));
label("linked\underline{\hspace{0.3cm}}ptr", (linked_offset - label_offset, linked + label_delta), black);
label("std::shared\underline{\hspace{0.3cm}}ptr", (shared_offset - label_offset, shared + label_delta), black);
label("boost::intruisive\underline{\hspace{0.3cm}}ptr", (intrusive_offset - label_offset, intrusive + label_delta), black);
label("std::unique\underline{\hspace{0.3cm}}ptr", (unique_offset - label_offset, unique + label_delta), black);
label("std::move benchmark : ", (bench_width * 2.0, max_height * 1.1));
\end{asy}
\end{minipage}

\begin{minipage}[h]{0.4\linewidth}
\begin{asy}
real linked = 1187;
real shared = 3527;
real intrusive = 996;
real unique = 786;
real linked_disp = 5;
real shared_disp = 51;
real intrusive_disp = 18;
real unique_disp = 12;real bench_width = 1624.0;
real max_height = 3527;

real arrow_offset = bench_width / 4.0 * 1.1;
real point_offset = arrow_offset * 2 / 3;
real linked_offset = arrow_offset + bench_width;
real shared_offset = arrow_offset + 2 * bench_width;
real intrusive_offset = arrow_offset + 3 * bench_width;
real unique_offset = arrow_offset + 4 * bench_width;
real label_offset = (shared_offset - linked_offset) / 2.0;

size(20cm,0);
draw((arrow_offset / 2, 0) -- (arrow_offset / 2, max_height),arrow=Arrow);

label(
    scale(0.5) * ("" + string(linked) + ""),
    (point_offset, linked),
    gray
);
label(
    scale(0.5) * ("" + string(shared) + ""),
    (point_offset, shared),
    gray
);
label(
    scale(0.5) * ("" + string(intrusive) + ""),
    (point_offset, intrusive),
    gray
);
label(
    scale(0.5) * ("" + string(unique) + ""),
    (point_offset, unique),
    gray
);
path lin = box((arrow_offset,0), (linked_offset,linked));
fill(lin, deepgreen);

path sha = box((linked_offset,0), (shared_offset,shared));
fill(sha, royalblue);

path intr = box((shared_offset,0), (intrusive_offset,intrusive));
fill(intr, magenta);

path uniq = box((intrusive_offset,0), (unique_offset,unique));
fill(uniq, heavyred);

real disp_eps = bench_width / 20.0;
draw(
    (arrow_offset, linked) 
    -- (arrow_offset, linked + linked_disp) 
    -- (arrow_offset + disp_eps, linked + linked_disp) 
    -- (arrow_offset - disp_eps, linked + linked_disp) 
    -- (arrow_offset, linked + linked_disp)
    -- (arrow_offset, linked - linked_disp)
    -- (arrow_offset + disp_eps, linked - linked_disp) 
    -- (arrow_offset - disp_eps, linked - linked_disp) 
    -- (arrow_offset, linked - linked_disp)
, gray);
draw(
    (linked_offset, shared) 
    -- (linked_offset, shared + shared_disp) 
    -- (linked_offset + disp_eps, shared + shared_disp) 
    -- (linked_offset - disp_eps, shared + shared_disp) 
    -- (linked_offset, shared + shared_disp)
    -- (linked_offset, shared - shared_disp)
    -- (linked_offset + disp_eps, shared - shared_disp) 
    -- (linked_offset - disp_eps, shared - shared_disp) 
    -- (linked_offset, shared - shared_disp)
, gray);
draw(
    (shared_offset, intrusive) 
    -- (shared_offset, intrusive + intrusive_disp) 
    -- (shared_offset + disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive + intrusive_disp) 
    -- (shared_offset, intrusive + intrusive_disp)
    -- (shared_offset, intrusive - intrusive_disp)
    -- (shared_offset + disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset - disp_eps, intrusive - intrusive_disp) 
    -- (shared_offset, intrusive - intrusive_disp)
, gray);
draw(
    (intrusive_offset, unique) 
    -- (intrusive_offset, unique + unique_disp) 
    -- (intrusive_offset + disp_eps, unique + unique_disp) 
    -- (intrusive_offset - disp_eps, unique + unique_disp) 
    -- (intrusive_offset, unique + unique_disp)
    -- (intrusive_offset, unique - unique_disp)
    -- (intrusive_offset + disp_eps, unique - unique_disp) 
    -- (intrusive_offset - disp_eps, unique - unique_disp) 
    -- (intrusive_offset, unique - unique_disp)
, gray);

real label_delta = 0.03 * max(max(linked, shared), max(intrusive, unique));
label("linked\underline{\hspace{0.3cm}}ptr", (linked_offset - label_offset, linked + label_delta));
label("std::shared\underline{\hspace{0.3cm}}ptr", (shared_offset - label_offset, shared + label_delta));
label("boost::intruisive\underline{\hspace{0.3cm}}ptr", (intrusive_offset - label_offset, intrusive + label_delta));
label("std::unique\underline{\hspace{0.3cm}}ptr", (unique_offset - label_offset, unique + label_delta));
label("real usecase (decart treee) benchmark : ", (bench_width * 2.0, max_height * 1.1));
\end{asy}
\end{minipage}

% \begin{figure}[h!]
%  \begin{minipage}[h]{0.4\linewidth}{1.0\textwidth}
%   \centering
%   \includegraphics{alloc}
%      \label{fig:sub:subfigure1}
%  \end{minipage}
%  \caption{\textsl{Figure text.}}
%  \label{fig:whole_figure}
%  \end{figure}
